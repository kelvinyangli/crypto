#' Fast Fourier Transform
#'
#' Fast Fourier Transform (FFT) that gets sample representation of
#' polynomials from their coefficient representations. This is an
#' efficient iterative FFT implementation as described on page 917 of
#' the book "Introduction to Algorithms" 3rd edition by Thomas Cormen
#' et al.
#' @param a A vector of polynomial coefficients from the smallest to the
#' highest power (or samples when inverser is set to TRUE).
#' That is, a=(a_0,a_1, ..., a_n-1). Ideally, the length
#' of a is a power of 2. If not, it will be packed with 0s at the back
#' to make it so. Hence, the output will be a vector of length n that
#' is a power of 2.
#' @param inverse A logical parameter. The default is FALSE. When set
#' to TRUE, the function will calculate the inverse of FFT.
#' @export

fft = function(a, inverse = FALSE) {

  n = length(a)
  p = log2(n) # power of 2
  # if p is not an integer, that is n is not a power of 2
  # then pack a with 0s at the back
  if (p %% 1 != 0) {

    q = 2 ^ ceiling(p)
    a = c(a, rep(0, q - n))
    n = q

  }

  # get a into the desired order using bit_reverse
  A = bit_reverse(a)
  for (s in 1:log2(n)) {

    m = 2 ^ s
    # the principle m-th root of unity
    # the other m-th roots of unity can be generated by taking
    # integer powers of the principle root
    omegaM = complex(real = cos(2 * pi / m), imaginary = sin(2 * pi / m))
    # if inverse, use complex conjugate
    if (inverse) omegaM = Conj(omegaM)
    for (k in seq(1, n, m)) {

      omega = 1
      for (j in 1:(m / 2)) {

        t = omega * A[k + j - 1 + m / 2]
        u = A[k + j - 1]
        A[k + j - 1] = u + t
        A[k + j - 1 + m / 2] = u - t
        omega = omega * omegaM

      }

    }

  }

  if (inverse) A = A / n

  return(A)

}
